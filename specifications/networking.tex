\subsubsection{Networking}
Computer networks and communication systems are not a new subject and clearly much attention has been given towards communication between networked embedded devices.  The design of the \netlet had unique specifications which meant many of the low-level and trivial protocols were insufficient.  We envisioned a product that \emph{anybody} could pick up at a store, take home, and start controlling and monitoring their power remotely.   Multiple \netlets could be controlled from a single interface.  \netlets update the controller charts and data in real time, communicate to server asynchronously when connected loads turn on and off, and handle asynchronous control messages received from the user interface.  The user interface must be accessible from any other web-enabled device. The user should easily be able to interface with the \netlet and therefore sending control messages should be accesible via a REST-ful API and user chart data available as JSON.  These constraints implied that the backend software for maintaining user data and controlling the device should not be hosted on the device itself, but rather hosted on a separate public-facing server.\\

The \netlet asynchronously receives commands from an instance of the server application and it was essential for ease of use that controlling the device be accessible from outside of ones home network and that no port forwarding, router configuration, or end-user networking be necessary at any step. The group considered many of the existing so-called \emph{sensor networks} that are already in use such as the popular Pachube\footnote{\url{http://pachube.com}}, ThingSpeak\footnote{\url{http://thingspeak.com}}, and other software stacks for Wireless Sensor Networks (WSNs).  Pachube and ThingSpeak both market themselves as data infrastructures for the internet of things and are both very mature products working in a similar space.  That said, both systems are mostly designed for geeks and hobbyists and there is an inherent limitation in that they rely solely on HTTP \texttt{GET} and \texttt{POST} requests.\\

We note here that the HTTP protocol is request-response oriented and that the client-server communications can only be initiated from the client side.  Though HTTP is not the only option at this layer of the network stack (alternatives include MTP1, MQTT, and the like), its ubiquity,  software stability, and the assurance of access from all breeds of mobile and desktop devices make it the de-facto choice for the controller application's public interface (API).   Thus, if we imagine the user interacting with the controller application from their mobile device and insist that there is no open incoming port on the \netlet, then  it is not immediately clear how the control messages can be relayed to the \netlet devices.  Possible implementations are discussed:

\paragraph{HTTP Polling} Polling via an HTTP \texttt{GET} request is the simplest approach to this problem.  Here, the \netlet device would simply be making requests of the controller server at a fixed rate and each request would also include the latest measured data.  If the user had clicked an option in the controller since the device's last request, it would be noted in the request response and dealt with.  The biggest downside to this approach is that the messages are not particularly responsive and the delay is a direct function of the polling frequency.

\paragraph{Long-Polling} Fundamentally, long-polling is not too different from traditional HTTP polling.  In this situation, an online \netlet periodically makes a request of the controller for any updates.  If the controller has a response, the response is sent immediately, however if the server has no message for the client, then the responding thread hangs on the \texttt{GET} request.  No response is served until a message for the client arrives.  If no controller interaction occurs before the \netlet's next data set update, then the \netlet simply sends the data in another request.  The server drops the old request and now waits on the new one.  Unlike traditional polling, long-polling fakes asynchronous communication over historical HTTP. That said, long-polling requires a special response server that is built to handle many idle threads. \cite{longpoll}

\paragraph{Persistent SSH Tunnels} With persistent SSH tunnels, the controller server whould be running a Secure Shell daemon and the \netlet devices would continually try to connect to this server and reverse bind one of the machines available port.  In this configuration, though only the controlling server is facing the public, the \netlet is actively reaching out to the controller and creating a returning tunnel.  The \netlet would easily be able to log measurements on the controller, while the controller could just as easily execute commands on the \netlet.  As far as reaching our goal of bi-directional asynchronous communication is concerned, this approach works very well and, in fact, is often used in practice using the tool \texttt{stunnel}.\footnote{\url{http://www.stunnel.org}} Nevertheless, maintaining custom software to track \netlets and their connected ports seemed difficult and consultation with an IT professional with experience in distributed NAT-evasion suggested we reconsider the necessary time investment.

\paragraph{Distributed Messaging \& XMPP} The Extensible Messaging and Presence Protocol -- XMPP -- uses a client-server architecture, however, it is decentralized and no authoritative server exists.  Often referred to as ``Jabber,'' XMPP typically runs on port 5222 and Jabber IDs are of the same structure as e-mail address.  Much like e-mail, anyone can run their own XMPP server and XMPP is an open standard.  XMPP servers communicate with other XMPP servers to relay messages and presence updates accordingly.  XMPP technologies have been in use since 1998 by companies like Sun Microsystems and Google.    Technically, XMPP behaves much like long-polling and of note is that it still requires a separate XMPP server from the HTTP server. Nevertheless, XMPP's distributed nature and design makes it incredibly well-suited for unavoidable NAS issues and unclear network paths.  Client-to-server communication is in the XML format and message bodies as well can be in their own XML namespace.  Server-to-server communication happens in XML as well and ensures that clients need not directly connect to the client they wish to communicate with nor the domain server for said client.  Clients communicate with a connected server and servers manage transferring the message to the appropriate XMPP domain.  Public Jabber servers are run by Jabber.org and Google and the XMPP standard inherently provides SASL and TLS security at the core level.  The protocol supports certificates and SSL in more robust setups.  Lastly, as the name should suggest, the markup is extensible and custom functionality can be built on top of the XMPP such as instant messaging, newtork management, content syndication, live collaboration tools, file sharing. We are used to using XMPP's availability messages and status messages in IM clients like Google Talk, but these types of indicator messages are defined at the protocol level.
\newline
\\
In light of the research above, the technical merits of the XMPP protocol clearly outweigh the security benefits of \texttt{stunnel}, the ubiquity of HTTP polling, or the hip-factor of Comet long-polling. XMPP is clearly the most well-suited protocol for a distributed network of devices.  Moreover, the lack of well documented embedded XMPP implementations suggested that this route would be the most beneficial to the open source and embedded communities.\\

In a successful setup, the end-user could either use our \netlet cloud-hosted web-based controller and control their outlets from anywhere or host the controller application on their own hardware (such as a spare desktop PC, idle media center, or ARM-based router).  The downside of this second scenario is that it only allows control of the \netlet from the local network unless ports are configured, however it guarantees that the user's power consumption and device usage data never leaves the household, has no attached service fee or operation cost, and that the user run a PC 24/7 to presumably save power and energy.  Our belief is that the user is willing to pay for a convenient, simple product and that \netlets could be provided as SaaS -- Software as a Service.  If the product's success and the cost of server maintenance ever became an issue, there could be a cost for using our hosting (much like blog software provider/hoster WordPress model\footnote{\url{http://wordpress.com}}) and the software would still be freely available to those users who want to support their own product experience.\\

Though our implementation uses a discrete ARM \arm development board for managing network connections and smaller 8-bit modules to control the relays, after replacing the \rsserial connections with a wireless interface it could certainly make sense that the functionality of the ARM board be integrated with existing in-home network-enabled ARM architecture devices such as routers, set-top boxes, mobile phones, or tablet computers.   After the protocol and topology were defined and functioning using \ethernet , \wifi support could be added in software and added trivially in hardware with a USB dongle.  Since constructing a custom board with features matching the \olimex was beyond the scope of \course, we add an integrated connectivity chip from high-volume suppliers like Broadcom to the specifications of the board we would produce were we to take this concept further.\\

The device should plug into the wall outlet for \SI{120}{\volt} and \ethernet.  Like setting up a wireless router, \wifi can be initially configured over \ethernet or USB -- by treating the \netlet as networked or USB mass storage device -- and no special software is necessary for the user to integrate \netlets with their existing digital lifestyle.\\

\subsubsection{Wireless Spectra}

When most people talk about wireless networking they are usually referring to the standard sponsored by the Wifi Alliance and established under the name IEEE 802.11. While nearly ubiquitous, this standard has some issues which has let a new standard 802.14.4 emerge and thrive in the embedded networking world under the names Zigbee and 6LowPan.
\paragraph{Wifi} Wifi has been used for computer networking for over a decade. Consequently, many buildings are now equipped with a wifi router that allows devices to connect to the network

\begin{itemize}
\item Router/Peripherals
% could include blurb on smart routers here
% "we could have integrated with X router ..."
\item Wireless standards
	% Ethernet, Zigbee, WiFi, 6LowPan, Custom
\item Wifi Device
\end{itemize}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../netlets"
%%% End: 
